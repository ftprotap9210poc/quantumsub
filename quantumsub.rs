/*
‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ  ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà     ‚ñà‚ñë‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà   ‚ñÑ‚ñÑ‚ñÑ       ‚ñà‚ñà‚ñà‚ñÑ ‚ñÑ‚ñà‚ñà‚ñà‚ñì ‚ñà‚ñà‚ñì‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà 
‚ñí‚ñà‚ñà‚ñÄ ‚ñà‚ñà‚ñå‚ñí‚ñà‚ñà‚ñí  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñë ‚ñà ‚ñë‚ñà‚ñë‚ñì‚ñà   ‚ñÄ ‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñÑ    ‚ñì‚ñà‚ñà‚ñí‚ñÄ‚ñà‚ñÄ ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñì‚ñà   ‚ñÄ 
‚ñë‚ñà‚ñà   ‚ñà‚ñå‚ñí‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñë ‚ñà ‚ñë‚ñà ‚ñí‚ñà‚ñà‚ñà   ‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñí‚ñà‚ñà  ‚ñÄ‚ñà‚ñÑ  ‚ñì‚ñà‚ñà    ‚ñì‚ñà‚ñà‚ñë‚ñì‚ñà‚ñà‚ñë ‚ñà‚ñà‚ñì‚ñí‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñí‚ñà‚ñà‚ñà   
‚ñë‚ñì‚ñà‚ñÑ   ‚ñå‚ñí‚ñà‚ñà   ‚ñà‚ñà‚ñë‚ñë‚ñà‚ñë ‚ñà ‚ñë‚ñà ‚ñí‚ñì‚ñà  ‚ñÑ ‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñë‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà ‚ñí‚ñà‚ñà    ‚ñí‚ñà‚ñà ‚ñí‚ñà‚ñà‚ñÑ‚ñà‚ñì‚ñí ‚ñí‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñí‚ñì‚ñà  ‚ñÑ 
‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñì ‚ñë ‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñë‚ñà‚ñà‚ñí‚ñà‚ñà‚ñì ‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí ‚ñì‚ñà   ‚ñì‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñí   ‚ñë‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñí ‚ñë  ‚ñë‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñí
 ‚ñí‚ñí‚ñì  ‚ñí ‚ñë ‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë ‚ñë ‚ñì‚ñë‚ñí ‚ñí  ‚ñë‚ñë ‚ñí‚ñë ‚ñë‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë ‚ñí‚ñí   ‚ñì‚ñí‚ñà‚ñë‚ñë ‚ñí‚ñë   ‚ñë  ‚ñë‚ñí‚ñì‚ñí‚ñë ‚ñë  ‚ñë‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë‚ñë‚ñë ‚ñí‚ñë ‚ñë
 ‚ñë ‚ñí  ‚ñí   ‚ñë ‚ñí ‚ñí‚ñë   ‚ñí ‚ñë ‚ñë   ‚ñë ‚ñë  ‚ñë  ‚ñë‚ñí ‚ñë ‚ñí‚ñë  ‚ñí   ‚ñí‚ñí ‚ñë‚ñë  ‚ñë      ‚ñë‚ñë‚ñí ‚ñë       ‚ñë‚ñí ‚ñë ‚ñí‚ñë ‚ñë ‚ñë  ‚ñë
 ‚ñë ‚ñë  ‚ñë ‚ñë ‚ñë ‚ñë ‚ñí    ‚ñë   ‚ñë     ‚ñë     ‚ñë‚ñë   ‚ñë   ‚ñë   ‚ñí   ‚ñë      ‚ñë   ‚ñë‚ñë         ‚ñë‚ñë   ‚ñë    ‚ñë   
   ‚ñë        ‚ñë ‚ñë      ‚ñë       ‚ñë  ‚ñë   ‚ñë           ‚ñë  ‚ñë       ‚ñë               ‚ñë        ‚ñë  ‚ñë
*/

use std::{
    collections::{BTreeMap, HashMap, HashSet},
    fs::{self, File, OpenOptions},
    io::{BufRead, BufReader, Write},
    net::{IpAddr, SocketAddr, ToSocketAddrs},
    path::{Path, PathBuf},
    sync::{
        atomic::{AtomicBool, AtomicUsize, Ordering},
        Arc, Mutex,
    },
    time::{Duration, Instant, SystemTime},
};
use clap::{App, Arg, ArgMatches, SubCommand, crate_authors, crate_version, crate_description};
use console::{style, Emoji};
use indicatif::{
    HumanDuration, MultiProgress, ParallelProgressIterator, ProgressBar, ProgressStyle,
};
use lazy_static::lazy_static;
use rayon::prelude::*;
use reqwest::{
    blocking::{Client, ClientBuilder},
    redirect::Policy,
};
use serde_json::{json, to_string_pretty};
use trust_dns_resolver::{
    config::{ResolverConfig, ResolverOpts},
    Name, Resolver,
};
use regex::Regex;
use std::process::Command;
use sysinfo::{System, SystemExt};

// Emojis for UI
static QUANTUM: Emoji<'_, '_> = Emoji("‚öõÔ∏è ", "");
static CHECK: Emoji<'_, '_> = Emoji("‚úÖ ", "");
static CROSS: Emoji<'_, '_> = Emoji("‚ùå ", "");
static WARN: Emoji<'_, '_> = Emoji("‚ö†Ô∏è ", "");
static LOCK: Emoji<'_, '_> = Emoji("üîí ", "");
static ROCKET: Emoji<'_, '_> = Emoji("üöÄ ", "");
static AI: Emoji<'_, '_> = Emoji("üß† ", "");
static FIRE: Emoji<'_, '_> = Emoji("üî• ", "");
static HELP: Emoji<'_, '_> = Emoji("üí° ", "");

// Constants
const DEFAULT_THREADS: usize = 2000;
const DEFAULT_TIMEOUT: u64 = 1;
const DEFAULT_WORDLIST: &str = "quantum_wordlist.txt";
const VERSION: &str = "5.1";
const MAX_RECURSION_DEPTH: usize = 5;
const AI_MODEL_PATH: &str = "quantum_model.bin";

lazy_static! {
    static ref COMMON_PORTS: Vec<u16> = vec![
        80, 443, 8080, 8443, 22, 21, 25, 3306, 3389, 5432, 27017, 6379, 11211, 
        9200, 9300, 5984, 27018, 9201, 5601, 15672, 8161, 61616, 8161, 9000
    ];
    static ref TECH_SIGNATURES: HashMap<&'static str, Vec<&'static str>> = {
        let mut m = HashMap::new();
        m.insert("WordPress", vec!["wp-content", "wp-includes", "wordpress"]);
        m.insert("Laravel", vec!["laravel", "mix-manifest.json"]);
        m.insert("Drupal", vec!["sites/all", "misc/drupal.js"]);
        m.insert("Joomla", vec!["media/system/js", "components/com_"]);
        m.insert("Nginx", vec!["nginx", "Server: nginx"]);
        m.insert("Apache", vec!["Apache", "Server: Apache"]);
        m.insert("Express", vec!["X-Powered-By: Express"]);
        m.insert("React", vec!["__reactInternalInstance", "react-dom"]);
        m.insert("Vue", vec!["__vue__", "vue.runtime"]);
        m.insert("Docker", vec!["Docker", "docker"]);
        m.insert("Kubernetes", vec!["kubernetes", "k8s"]);
        m.insert("GraphQL", vec!["graphql", "GraphQL"]);
        m.insert("Elasticsearch", vec!["elasticsearch", "es"]);
        m.insert("MongoDB", vec!["mongodb", "mongo"]);
        m
    };
    static ref VULN_PATTERNS: HashMap<&'static str, Regex> = {
        let mut m = HashMap::new();
        m.insert("SQL Injection", Regex::new(r"(?i)(select|union|insert|delete|update|drop|alter|create).*from").unwrap());
        m.insert("XSS", Regex::new(r"(?i)(<script|alert\()").unwrap());
        m.insert("LFI", Regex::new(r"(?i)(\.\./|\.\.\\|~/|/etc/passwd)").unwrap());
        m.insert("RCE", Regex::new(r"(?i)(system|exec|shell_exec|passthru)\(.*\)").unwrap());
        m.insert("JWT", Regex::new(r"(?i)(eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*)").unwrap());
        m
    };
}

#[derive(Debug, Clone)]
struct QuantumConfig {
    threads: usize,
    timeout: u64,
    bruteforce: bool,
    resolve: bool,
    portscan: bool,
    techdetect: bool,
    recursive: bool,
    verbose: bool,
    screenshot: bool,
    vuln_check: bool,
    output_dir: PathBuf,
    ai_analysis: bool,
    cloud_detect: bool,
    api_scan: bool,
    stealth_mode: bool,
    tor_proxy: bool,
    whois_lookup: bool,
    ssl_audit: bool,
    archive_scan: bool,
}

#[derive(Debug)]
struct QuantumResults {
    subdomains: HashMap<String, HashSet<String>>,
    ip_mappings: HashMap<String, Vec<IpAddr>>,
    ports: HashMap<String, Vec<u16>>,
    technologies: HashMap<String, Vec<String>>,
    screenshots: HashMap<String, String>,
    vulnerabilities: HashMap<String, Vec<String>>,
    dns_records: HashMap<String, Vec<String>>,
    cloud_resources: HashMap<String, Vec<String>>,
    api_endpoints: HashMap<String, Vec<String>>,
    ai_insights: HashMap<String, Vec<String>>,
    whois_data: HashMap<String, String>,
    ssl_info: HashMap<String, Vec<String>>,
    archived_urls: HashMap<String, Vec<String>>,
}

impl QuantumResults {
    fn new() -> Self {
        Self {
            subdomains: HashMap::new(),
            ip_mappings: HashMap::new(),
            ports: HashMap::new(),
            technologies: HashMap::new(),
            screenshots: HashMap::new(),
            vulnerabilities: HashMap::new(),
            dns_records: HashMap::new(),
            cloud_resources: HashMap::new(),
            api_endpoints: HashMap::new(),
            ai_insights: HashMap::new(),
            whois_data: HashMap::new(),
            ssl_info: HashMap::new(),
            archived_urls: HashMap::new(),
        }
    }
}

fn main() {
    let start_time = Instant::now();
    let matches = App::new("QuantumSub Recon Elite+")
        .version(crate_version!())
        .author(crate_authors!("\n"))
        .about(crate_description!())
        .after_help(format!("{}{}",
            HELP,
            style("\nEXAMPLES:\n").bold().underlined(),
            style("  Basic scan:              quantumsub quantum -t target.com\n").cyan(),
            style("  Full reconnaissance:     quantumsub quantum -t target.com -A -C -P -V -W\n").cyan(),
            style("  Continuous monitoring:    quantumsub monitor -t target.com -i 60\n").cyan(),
            style("  Analyze results:          quantumsub analyze -i scan_results/ -r -p\n").cyan(),
            style("\nDOCUMENTATION:\n").bold().underlined(),
            style("  For full documentation, visit: https://github.com/fthacker101/quantumsub\n").blue()
        ))
        .subcommand(
            SubCommand::with_name("quantum")
                .about("Execute quantum reconnaissance scan")
                .after_help(format!("{}{}",
                    HELP,
                    style("\nSCAN TYPES:\n").bold().underlined(),
                    style("  Standard Scan:       Basic subdomain enumeration\n").cyan(),
                    style("  Deep Scan:          -A -C -P -V -W flags for full analysis\n").cyan(),
                    style("  Stealth Scan:       -S -X for covert operations\n").cyan(),
                    style("\nCONFIGURATION TIPS:\n").bold().underlined(),
                    style("  For large scans, adjust -j and -o parameters based on system resources\n").cyan(),
                    style("  Use -W for WHOIS lookups and -Z for SSL certificate analysis\n").cyan()
                ))
                .arg(Arg::with_name("target")
                    .help("Primary target domain to scan")
                    .short('t')
                    .long("target")
                    .takes_value(true)
                    .required_unless("target_list")
                    .display_order(1))
                .arg(Arg::with_name("target_list")
                    .help("File containing list of target domains (one per line)")
                    .short('T')
                    .long("targets")
                    .takes_value(true)
                    .display_order(2))
                .arg(Arg::with_name("wordlist")
                    .help("Path to quantum subdomain wordlist")
                    .short('w')
                    .long("wordlist")
                    .default_value(DEFAULT_WORDLIST)
                    .display_order(3))
                .arg(Arg::with_name("threads")
                    .help("Number of quantum threads (default: 2000)")
                    .short('j')
                    .long("threads")
                    .default_value(&DEFAULT_THREADS.to_string())
                    .display_order(4))
                .arg(Arg::with_name("timeout")
                    .help("Request timeout in seconds (default: 1)")
                    .short('o')
                    .long("timeout")
                    .default_value(&DEFAULT_TIMEOUT.to_string())
                    .display_order(5))
                .arg(Arg::with_name("output")
                    .help("Output directory for results (default: quantum_results)")
                    .short('O')
                    .long("output")
                    .default_value("quantum_results")
                    .display_order(6))
                .arg(Arg::with_name("bruteforce")
                    .help("Enable quantum bruteforce mode (aggressive scanning)")
                    .short('b')
                    .long("bruteforce")
                    .display_order(7))
                .arg(Arg::with_name("resolve")
                    .help("Perform comprehensive DNS resolution")
                    .short('r')
                    .long("resolve")
                    .display_order(8))
                .arg(Arg::with_name("portscan")
                    .help("Scan all common ports (TCP)")
                    .short('p')
                    .long("portscan")
                    .display_order(9))
                .arg(Arg::with_name("tech")
                    .help("Perform deep technology detection")
                    .short('c')
                    .long("tech")
                    .display_order(10))
                .arg(Arg::with_name("recursive")
                    .help("Enable recursive discovery (depth=5)")
                    .short('R')
                    .long("recursive")
                    .display_order(11))
                .arg(Arg::with_name("screenshot")
                    .help("Capture visual reconnaissance data")
                    .short('s')
                    .long("screenshot")
                    .display_order(12))
                .arg(Arg::with_name("vuln")
                    .help("Perform vulnerability assessment")
                    .short('V')
                    .long("vuln")
                    .display_order(13))
                .arg(Arg::with_name("ai")
                    .help("Enable quantum AI analysis module")
                    .short('A')
                    .long("ai")
                    .display_order(14))
                .arg(Arg::with_name("cloud")
                    .help("Detect cloud infrastructure and services")
                    .short('C')
                    .long("cloud")
                    .display_order(15))
                .arg(Arg::with_name("api")
                    .help("Discover and analyze API endpoints")
                    .short('P')
                    .long("api")
                    .display_order(16))
                .arg(Arg::with_name("stealth")
                    .help("Enable stealth mode (rate limiting)")
                    .short('S')
                    .long("stealth")
                    .display_order(17))
                .arg(Arg::with_name("tor")
                    .help("Route traffic through TOR network")
                    .short('X')
                    .long("tor")
                    .display_order(18))
                .arg(Arg::with_name("whois")
                    .help("Perform WHOIS lookups for discovered domains")
                    .short('W')
                    .long("whois")
                    .display_order(19))
                .arg(Arg::with_name("ssl")
                    .help("Analyze SSL/TLS certificates")
                    .short('Z')
                    .long("ssl")
                    .display_order(20))
                .arg(Arg::with_name("archive")
                    .help("Check Wayback Machine for archived URLs")
                    .short('Y')
                    .long("archive")
                    .display_order(21))
                .arg(Arg::with_name("verbose")
                    .help("Enable verbose output")
                    .short('v')
                    .long("verbose")
                    .display_order(22))
        )
        .subcommand(
            SubCommand::with_name("analyze")
                .about("Analyze and visualize scan results")
                .after_help(format!("{}{}",
                    HELP,
                    style("\nANALYSIS MODES:\n").bold().underlined(),
                    style("  Basic Analysis:      Standard results processing\n").cyan(),
                    style("  AI Prediction:       -p flag for machine learning insights\n").cyan(),
                    style("  Reporting:           -r generates interactive HTML report\n").cyan(),
                    style("\nUSAGE TIPS:\n").bold().underlined(),
                    style("  Combine with -p for predictive threat modeling\n").cyan(),
                    style("  Use -r to generate client-ready reports\n").cyan()
                ))
                .arg(Arg::with_name("input")
                    .help("Directory containing scan results")
                    .short('i')
                    .long("input")
                    .required(true)
                    .display_order(1))
                .arg(Arg::with_name("report")
                    .help("Generate interactive HTML report")
                    .short('r')
                    .long("report")
                    .display_order(2))
                .arg(Arg::with_name("predict")
                    .help("Run quantum prediction model on results")
                    .short('p')
                    .long("predict")
                    .display_order(3))
                .arg(Arg::with_name("verbose")
                    .help("Enable verbose analysis output")
                    .short('v')
                    .long("verbose")
                    .display_order(4))
        )
        .subcommand(
            SubCommand::with_name("monitor")
                .about("Continuous subdomain monitoring")
                .after_help(format!("{}{}",
                    HELP,
                    style("\nMONITORING TIPS:\n").bold().underlined(),
                    style("  For production use, set interval (-i) based on change frequency\n").cyan(),
                    style("  Critical systems should use lower alert thresholds (-a)\n").cyan(),
                    style("  Combine with --notify for real-time alerts\n").cyan()
                ))
                .arg(Arg::with_name("target")
                    .help("Domain to monitor")
                    .required(true)
                    .display_order(1))
                .arg(Arg::with_name("interval")
                    .help("Check interval in minutes (default: 60)")
                    .short('i')
                    .long("interval")
                    .default_value("60")
                    .display_order(2))
                .arg(Arg::with_name("alert")
                    .help("Alert threshold for new subdomains")
                    .short('a')
                    .long("alert")
                    .takes_value(true)
                    .display_order(3))
                .arg(Arg::with_name("notify")
                    .help("Notification webhook URL")
                    .short('n')
                    .long("notify")
                    .takes_value(true)
                    .display_order(4))
                .arg(Arg::with_name("verbose")
                    .help("Enable verbose monitoring output")
                    .short('v')
                    .long("verbose")
                    .display_order(5))
        )
        .subcommand(
            SubCommand::with_name("generate")
                .about("Generate custom wordlists and patterns")
                .after_help(format!("{}{}",
                    HELP,
                    style("\nGENERATION TYPES:\n").bold().underlined(),
                    style("  Wordlists:          Subdomain permutations\n").cyan(),
                    style("  Patterns:           Common vulnerability patterns\n").cyan(),
                    style("  Configs:            Pre-configured scan profiles\n").cyan()
                ))
                .arg(Arg::with_name("wordlist")
                    .help("Generate subdomain wordlist")
                    .short('w')
                    .long("wordlist")
                    .takes_value(true)
                    .display_order(1))
                .arg(Arg::with_name("patterns")
                    .help("Generate vulnerability patterns")
                    .short('p')
                    .long("patterns")
                    .takes_value(true)
                    .display_order(2))
                .arg(Arg::with_name("size")
                    .help("Number of entries to generate")
                    .short('s')
                    .long("size")
                    .default_value("1000000")
                    .display_order(3))
                .arg(Arg::with_name("output")
                    .help("Output directory")
                    .short('o')
                    .long("output")
                    .default_value("generated")
                    .display_order(4))
        )
        .arg(Arg::with_name("help")
            .short('h')
            .long("help")
            .help("Show help information")
            .global(true))
        .arg(Arg::with_name("version")
            .short('V')
            .long("version")
            .help("Show version information")
            .global(true))
        .get_matches();

    // Handle global help and version flags
    if matches.is_present("help") {
        println!("{}", matches.usage());
        println!("For command-specific help: quantumsub <command> -h");
        std::process::exit(0);
    }

    if matches.is_present("version") {
        println!("QuantumSub Recon Elite+ v{}", VERSION);
        std::process::exit(0);
    }

    print_banner();
    check_system_resources();

    match matches.subcommand() {
        ("quantum", Some(quantum_matches)) => {
            if quantum_matches.is_present("help") {
                println!("{}", quantum_matches.usage());
                println!("For detailed documentation: https://github.com/ftprotap9210poc/quantum/");
                std::process::exit(0);
            }

            let config = QuantumConfig {
                threads: quantum_matches.value_of("threads").unwrap().parse().unwrap_or(DEFAULT_THREADS),
                timeout: quantum_matches.value_of("timeout").unwrap().parse().unwrap_or(DEFAULT_TIMEOUT),
                bruteforce: quantum_matches.is_present("bruteforce"),
                resolve: quantum_matches.is_present("resolve"),
                portscan: quantum_matches.is_present("portscan"),
                techdetect: quantum_matches.is_present("tech"),
                recursive: quantum_matches.is_present("recursive"),
                verbose: quantum_matches.is_present("verbose"),
                screenshot: quantum_matches.is_present("screenshot"),
                vuln_check: quantum_matches.is_present("vuln"),
                output_dir: PathBuf::from(quantum_matches.value_of("output").unwrap()),
                ai_analysis: quantum_matches.is_present("ai"),
                cloud_detect: quantum_matches.is_present("cloud"),
                api_scan: quantum_matches.is_present("api"),
                stealth_mode: quantum_matches.is_present("stealth"),
                tor_proxy: quantum_matches.is_present("tor"),
                whois_lookup: quantum_matches.is_present("whois"),
                ssl_audit: quantum_matches.is_present("ssl"),
                archive_scan: quantum_matches.is_present("archive"),
            };

            let targets = if let Some(domain) = quantum_matches.value_of("target") {
                vec![domain.to_string()]
            } else if let Some(target_list) = quantum_matches.value_of("target_list") {
                match load_domains(target_list) {
                    Ok(list) => list,
                    Err(e) => {
                        eprintln!("{} Failed to load target list: {}", CROSS, e);
                        std::process::exit(1);
                    }
                }
            } else {
                eprintln!("{} No target specified!", CROSS);
                std::process::exit(1);
            };

            let wordlist = match load_wordlist(quantum_matches.value_of("wordlist").unwrap()) {
                Ok(list) => list,
                Err(e) => {
                    eprintln!("{} Failed to load quantum wordlist: {}", CROSS, e);
                    std::process::exit(1);
                }
            };

            quantum_recon(&targets, &wordlist, config, start_time);
        }
        ("analyze", Some(analyze_matches)) => {
            if analyze_matches.is_present("help") {
                println!("{}", analyze_matches.usage());
                println!("Analysis Guide: https://github.comftprotap9210poc/quantum/");
                std::process::exit(0);
            }
            quantum_analysis(analyze_matches);
        }
        ("monitor", Some(monitor_matches)) => {
            if monitor_matches.is_present("help") {
                println!("{}", monitor_matches.usage());
                println!("Monitoring Setup: https://github.comftprotap9210poc/quantum/");
                std::process::exit(0);
            }
            quantum_monitoring(monitor_matches);
        }
        ("generate", Some(generate_matches)) => {
            if generate_matches.is_present("help") {
                println!("{}", generate_matches.usage());
                println!("Generation Guide: https://github.comftprotap9210poc/quantum/");
                std::process::exit(0);
            }
            quantum_generate(generate_matches);
        }
        _ => {
            println!("{}", matches.usage());
            println!("Try 'quantumsub <command> --help' for command-specific help");
            std::process::exit(0);
        }
    }
}

// ... [Previous implementation functions remain unchanged] ...

fn print_banner() {
    println!(
        "{}",
        style(
            r#"
  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñÑ‚ñÑ‚ñÑ       ‚ñà    ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñÑ ‚ñÑ‚ñà‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà   ‚ñÑ‚ñÑ‚ñÑ       ‚ñà‚ñà‚ñà‚ñÑ ‚ñÑ‚ñà‚ñà‚ñà‚ñì ‚ñà‚ñà‚ñì‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà 
‚ñí‚ñà‚ñà    ‚ñí ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñÑ     ‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñí‚ñÄ‚ñà‚ñÄ ‚ñà‚ñà‚ñí‚ñì‚ñà   ‚ñÄ ‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñÑ    ‚ñì‚ñà‚ñà‚ñí‚ñÄ‚ñà‚ñÄ ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñì‚ñà   ‚ñÄ 
‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñí‚ñà‚ñà  ‚ñÄ‚ñà‚ñÑ  ‚ñì‚ñà‚ñà  ‚ñí‚ñà‚ñà‚ñë‚ñì‚ñà‚ñà    ‚ñì‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñà   ‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñí‚ñà‚ñà  ‚ñÄ‚ñà‚ñÑ  ‚ñì‚ñà‚ñà    ‚ñì‚ñà‚ñà‚ñë‚ñì‚ñà‚ñà‚ñë ‚ñà‚ñà‚ñì‚ñí‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñí‚ñà‚ñà‚ñà   
  ‚ñí   ‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà ‚ñì‚ñì‚ñà  ‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà    ‚ñí‚ñà‚ñà ‚ñí‚ñì‚ñà  ‚ñÑ ‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñë‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà ‚ñí‚ñà‚ñà    ‚ñí‚ñà‚ñà ‚ñí‚ñà‚ñà‚ñÑ‚ñà‚ñì‚ñí ‚ñí‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñí‚ñì‚ñà  ‚ñÑ 
‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí ‚ñì‚ñà   ‚ñì‚ñà‚ñà‚ñí‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí   ‚ñë‚ñà‚ñà‚ñí‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí ‚ñì‚ñà   ‚ñì‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñí   ‚ñë‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñí ‚ñë  ‚ñë‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñí
‚ñí ‚ñí‚ñì‚ñí ‚ñí ‚ñë ‚ñí‚ñí   ‚ñì‚ñí‚ñà‚ñë‚ñë‚ñí‚ñì‚ñí ‚ñí ‚ñí ‚ñë ‚ñí‚ñë   ‚ñë  ‚ñë‚ñë‚ñë ‚ñí‚ñë ‚ñë‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë ‚ñí‚ñí   ‚ñì‚ñí‚ñà‚ñë‚ñë ‚ñí‚ñë   ‚ñë  ‚ñë‚ñí‚ñì‚ñí‚ñë ‚ñë  ‚ñë‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë‚ñë‚ñë ‚ñí‚ñë ‚ñë
‚ñë ‚ñë‚ñí  ‚ñë ‚ñë  ‚ñí   ‚ñí‚ñí ‚ñë‚ñë‚ñë‚ñí‚ñë ‚ñë ‚ñë ‚ñë  ‚ñë      ‚ñë ‚ñë ‚ñë  ‚ñë  ‚ñë‚ñí ‚ñë ‚ñí‚ñë  ‚ñí   ‚ñí‚ñí ‚ñë‚ñë  ‚ñë      ‚ñë‚ñë‚ñí ‚ñë       ‚ñë‚ñí ‚ñë ‚ñí‚ñë ‚ñë ‚ñë  ‚ñë
‚ñë  ‚ñë  ‚ñë    ‚ñë   ‚ñí    ‚ñë‚ñë‚ñë ‚ñë ‚ñë ‚ñë      ‚ñë      ‚ñë     ‚ñë‚ñë   ‚ñë   ‚ñë   ‚ñí   ‚ñë      ‚ñë   ‚ñë‚ñë         ‚ñë‚ñë   ‚ñë    ‚ñë   
      ‚ñë        ‚ñë  ‚ñë   ‚ñë            ‚ñë      ‚ñë  ‚ñë   ‚ñë           ‚ñë  ‚ñë       ‚ñë               ‚ñë        ‚ñë  ‚ñë
            "#
        )
        .blue()
    );
    println!(
        "{} {}",
        style("QuantumSub Recon Elite+").blue().bold(),
        style(format!("v{} by FT HACKER 101", VERSION)).blue()
    );
    println!();
}

// ... [Rest of the implementation remains unchanged] ...
